package actions

import (
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/gobuffalo/buffalo"
	"github.com/pkg/errors"
	"github.com/thenomemac/gofish/models"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Fishpic)
// DB Table: Plural (fishpics)
// Resource: Plural (Fishpics)
// Path: Plural (/fishpics)
// View Template Folder: Plural (/templates/fishpics/)

// FishpicsResource is the resource for the Fishpic model
type FishpicsResource struct {
	buffalo.Resource
}

// List gets all Fishpics. This function is mapped to the path
// GET /fishpics
func (v FishpicsResource) List(c buffalo.Context) error {
	files, err := ioutil.ReadDir("./db")
	if err != nil {
		errors.WithStack(err)
	}

	filenames := make([]string, len(files))
	for i, file := range files {
		filenames[i] = file.Name()
	}

	fishpics := make(models.Fishpics, len(filenames))

	for i, filename := range filenames {
		bytes, err := ioutil.ReadFile("./db/" + filename)
		if err != nil {
			errors.WithStack(err)
		}
		fmt.Println(filename, len(bytes))

		err = json.Unmarshal(bytes, &fishpics[i])
		if err != nil {
			errors.WithStack(err)
		}
	}

	return c.Render(200, r.JSON(fishpics))
}

func Find(model *models.Fishpic, id string) error {

	files, err := ioutil.ReadDir("./db")
	if err != nil {
		errors.WithStack(err)
	}

	for _, file := range files {
		if id == file.Name() {
			bytes, err := ioutil.ReadFile("./db/" + id)
			if err != nil {
				errors.WithStack(err)
			}

			err = json.Unmarshal(bytes, model)
			if err != nil {
				errors.WithStack(err)
			}
			return nil
		}

	}

	return errors.New("No data found with id: " + id)
}

// Show gets the data for one Fishpic. This function is mapped to
// the path GET /fishpics/{fishpic_id}
func (v FishpicsResource) Show(c buffalo.Context) error {
	// Allocate an empty Fishpic
	fishpic := &models.Fishpic{}

	// To find the Fishpic the parameter fishpic_id is used.
	if err := Find(fishpic, c.Param("fishpic_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.JSON(fishpic))
}

// New default implementation. Returns a 404
func (v FishpicsResource) New(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Create adds a Fishpic to the DB. This function is mapped to the
// path POST /fishpics
func (v FishpicsResource) Create(c buffalo.Context) error {
	// Allocate an empty Fishpic
	fishpic := &models.Fishpic{}
	fmt.Println("made it to here hmm...")
	fmt.Println(fishpic)
	fishpic.Init()
	fmt.Println(fishpic)
	// Bind fishpic to the html form elements
	if err := c.Bind(fishpic); err != nil {
		return errors.WithStack(err)
	}

	err := fishpic.ValidateAndSave()
	if err != nil {
		errors.WithStack(err)
	}

	return c.Render(201, r.JSON(fishpic))
}

// Edit default implementation. Returns a 404
func (v FishpicsResource) Edit(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Update changes a Fishpic in the DB. This function is mapped to
// the path PUT /fishpics/{fishpic_id}
func (v FishpicsResource) Update(c buffalo.Context) error {
	/*
		// Get the DB connection from the context
		tx, ok := c.Value("tx").(*pop.Connection)
		if !ok {
			return errors.WithStack(errors.New("no transaction found"))
		}

		// Allocate an empty Fishpic
		fishpic := &models.Fishpic{}p

		if err := tx.Find(fishpic, c.Param("fishpic_id")); err != nil {
			return c.Error(404, err)
		}

		// Bind Fishpic to the html form elements
		if err := c.Bind(fishpic); err != nil {
			return errors.WithStack(err)
		}

		verrs, err := tx.ValidateAndUpdate(fishpic)
		if err != nil {
			return errors.WithStack(err)
		}

		if verrs.HasAny() {
			// Render errors as JSON
			return c.Render(400, r.JSON(verrs))
		}

		return c.Render(200, r.JSON(fishpic))
	*/
	return c.Error(404, errors.New("not available"))
}

// Destroy deletes a Fishpic from the DB. This function is mapped
// to the path DELETE /fishpics/{fishpic_id}
func (v FishpicsResource) Destroy(c buffalo.Context) error {
	/*
		// Get the DB connection from the context
		tx, ok := c.Value("tx").(*pop.Connection)
		if !ok {
			return errors.WithStack(errors.New("no transaction found"))
		}

		// Allocate an empty Fishpic
		fishpic := &models.Fishpic{}

		// To find the Fishpic the parameter fishpic_id is used.
		if err := tx.Find(fishpic, c.Param("fishpic_id")); err != nil {
			return c.Error(404, err)
		}

		if err := tx.Destroy(fishpic); err != nil {
			return errors.WithStack(err)
		}

		return c.Render(200, r.JSON(fishpic))
	*/
	return c.Error(404, errors.New("not available"))
}
